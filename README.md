# AuthenticationFormProject

## Native часть

### Содержание и инструкция по запуску

Нативная часть работы состоит из следующих файлов:
* index и success - html-файлы;
* style - css-файл;
* script - js-файл.

Запуск выполняется через открытие файла index.html.

### Ответы на вопросы

Как сделана форма для людей с ограниченными возможностями❓ - Для слабовидящих используется кнопка "Версия для слабовидящих", при нажатии на которую к тегу <body> добавляется класс .accessible и в style.css применяется стиль body.accessible, где используются более высокая контрастность, увеличенные шрифты.

Какой подход был использован в верстке (блочная, flex, grid)❓ - Использовалась блочная модель для четкого деления на "шапку", основную часть и "подвал", а также применялся flexbox для выравнивания формы по центру (отображение формы с логином и паролем). Поскольку структура формы проста, то использование grid не было необходимым.

Какие брейкпоинты использовались и почему❓ - Были выбраны 768px и 480px, поскольку это одни из стандартных брейкпоинтов, первый из которых подходит для планшетов, а второй - для смартфонов (с уменьшением отступов, увеличением кнопок и полей).

Какой был выбран способ хранения данных для их последующего отображения и почему❓ - Был выбран localStorage для длительного хранения данных между сессиями. Если выбирать sessionStorage, то данные будут очищаться при закрытии вкладки.

Какие больше понравились функции - стрелочные или именованные, и почему❓ - Сильная разница не ощутима, но именованные функции понравились чуть больше в силу их привычного мне написания.

## WIth-infrastructure часть

### Содержание

* Добавлены тесты в папку __tests__

### Ответы на вопросы

Почему фиксируем версию Node через nvm и engines в package.json❓ - Фиксация через .nvmrc и engines в package.json обеспечивает единообразие среды разработки и предотвращает ошибки из-за несовместимости версий.

Почему строгая конфигурация TypeScript❓ - Строгая типизация позволяет находить ошибки еще до запуска и делает код более надежным. В конфигурации используется строгая проверка типов (strict, noImplicitAny, strictNullChecks и т.д.). Конфигурация направлена на строгую типизацию и совместимость с Node.js, что повышает надежность кода и упрощает отладку.

Почему выбрали Vite как сборщик❓ - Vite обеспечивает мгновенную перезагрузку, быструю сборку и лучшую поддержку TypeScript, что ускоряет разработку.

Почему выбрали ESLint и такую конфигурацию❓ - ESLint с плагином @typescript-eslint это стандарт качества кода. Также ESLint автоматизирует процесс анализа кода и позволяет интегрировать плагины для работы с тем же фреймворком React. Основные правила задают строгий стиль (semi, quotes) и предупреждают о неиспользуемых переменных. Отключение explicit-function-return-type уменьшает шум в коде на раннем этапе.

Почему выбрали Prettier и такую конфигурацию❓ - Prettier автоматически форматирует код по единым правилам, устраняя споры в стиле и ускоряя код-ревью. Использовалась готовая конфигурация, поскольку она уже предлагает общепринятые правила стиля.

Почему выбрали Jest/Vitest и такую конфигурацию❓ - Vitest/Jest легко настраиваются, быстро работают и поддерживают TypeScript, а jsdom позволяет тестировать DOM. Jest предоставляет удобную настройку и автопоиск тестов, что позволяет использовать его без явной конфигурации.

## Framework часть

### Содержание и инструкция по запуску

* Добавлен React в существующий проект
* Настроена среда разработки с поддержкой модулей и JSX
* Создан отдельный контейнер (id="react-root") в HTML
* В React приложении сделаны компоненты в папке src, которые же и рендерятся внутри контейнера react-root
* Убрано дублирование предыдущего содержимого index.html
* В терминале выполнились команды для установки React и плагина для Vite: npm install react react-dom и npm install --save-dev @vitejs/plugin-react
* Создан файл vite.config.ts

Запуск проекта происходит путем выполнения команды npm run dev и переходом по ссылке http://localhost:5173/index.html

### Ответы на вопросы

Почему не нужен стейт-менеджер❓ - Так как проект представляет собой простую форму с минимумом состояния, было принято решение не использовать стейт-менеджер. Для управления состоянием используются локальные хуки ('useState', 'useEffect'). Это делает архитектуру более простой.
Как разбит интерфейс и на какие компоненты❓ - Интерфейс разбит на переиспользуемые компоненты ('<LoginForm />', '<TulipFall />' и т.д.).
Как тестируются эти компоненты❓ - Покрытие тестов происходит посредством использования React Testing Library и они покрывают ключевые компоненты.
Есть ли дополнительные фичи❓ - Добавлен роутинг с помощью React Router (главная страница с формой авторизации + страница "о проекте" с краткой информацией).
