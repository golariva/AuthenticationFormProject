# AuthenticationFormProject

## Native часть

### Содержание и инструкция по запуску

Нативная часть работы состоит из следующих файлов:
* index и success - html-файлы;
* style - css-файл;
* script - js-файл.

Запуск выполняется через открытие файла index.html.

### Ответы на вопросы

Как сделана форма для людей с ограниченными возможностями❓ - Для слабовидящих используется кнопка "Версия для слабовидящих", при нажатии на которую к тегу <body> добавляется класс .accessible и в style.css применяется стиль body.accessible, где используются более высокая контрастность, увеличенные шрифты.

Какой подход был использован в верстке (блочная, flex, grid)❓ - Использовалась блочная модель для четкого деления на "шапку", основную часть и "подвал", а также применялся flexbox для выравнивания формы по центру (отображение формы с логином и паролем). Поскольку структура формы проста, то использование grid не было необходимым.

Какие брейкпоинты использовались и почему❓ - Были выбраны 768px и 480px, поскольку это одни из стандартных брейкпоинтов, первый из которых подходит для планшетов, а второй - для смартфонов (с уменьшением отступов, увеличением кнопок и полей).

Какой был выбран способ хранения данных для их последующего отображения и почему❓ - Был выбран localStorage для длительного хранения данных между сессиями. Если выбирать sessionStorage, то данные будут очищаться при закрытии вкладки.

Какие больше понравились функции - стрелочные или именованные, и почему❓ - Сильная разница не ощутима, но именованные функции понравились чуть больше в силу их привычного мне написания.

## WIth-infrastructure часть

Почему фиксируем версию Node через nvm и engines в package.json❓ - Фиксация через .nvmrc и engines в package.json обеспечивает единообразие среды разработки и предотвращает ошибки из-за несовместимости версий.

Почему строгая конфигурация TypeScript❓ - Строгая типизация позволяет находить ошибки еще до запуска и делает код более надежным. В конфигурации используется строгая проверка типов (strict, noImplicitAny, strictNullChecks и т.д.). Конфигурация направлена на строгую типизацию и совместимость с Node.js, что повышает надежность кода и упрощает отладку.

Почему выбрали Vite как сборщик❓ - Vite обеспечивает мгновенную перезагрузку, быструю сборку и лучшую поддержку TypeScript, что ускоряет разработку.

Почему выбрали ESLint и такую конфигурацию❓ - ESLint с плагином @typescript-eslint это стандарт качества кода. Также ESLint автоматизирует процесс анализа кода и позволяет интегрировать плагины для работы с тем же фреймворком React. Основные правила задают строгий стиль (semi, quotes) и предупреждают о неиспользуемых переменных. Отключение explicit-function-return-type уменьшает шум в коде на раннем этапе.

Почему выбрали Prettier и такую конфигурацию❓ - Prettier автоматически форматирует код по единым правилам, устраняя споры в стиле и ускоряя код-ревью. Использовалась готовая конфигурация, поскольку она уже предлагает общепринятые правила стиля.

Почему выбрали Jest/Vitest и такую конфигурацию❓ - Vitest/Jest легко настраиваются, быстро работают и поддерживают TypeScript, а jsdom позволяет тестировать DOM. Jest предоставляет удобную настройку и автопоиск тестов, что позволяет использовать его без явной конфигурации.